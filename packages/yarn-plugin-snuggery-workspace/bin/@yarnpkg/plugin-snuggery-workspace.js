/* eslint-disable */
module.exports = {
name: "@yarnpkg/plugin-snuggery-workspace",
factory: function (require) {
var plugin;plugin=(()=>{"use strict";var t={910:(t,e,r)=>{r.r(e),r.d(e,{default:()=>u});const s=require("@yarnpkg/cli"),a=require("@yarnpkg/core"),n=require("@yarnpkg/fslib"),i=require("@yarnpkg/plugin-pack");function o(t,e,r){return Object.create(t,{cwd:{value:e,writable:!1,configurable:!0},manifest:{value:a.Manifest.fromText(JSON.stringify(r)),writable:!1,configurable:!0}})}class c extends s.BaseCommand{constructor(){super(...arguments),this.json=!1}async execute(){const t=await a.Configuration.find(this.context.cwd,this.context.plugins);return(await a.StreamReport.start({configuration:t,stdout:this.context.stdout,includeFooter:!1,includeInfos:!0,json:this.json},async e=>{const{project:r,workspace:s}=await a.Project.find(t,this.context.cwd);if(!s)return void e.reportError(a.MessageName.UNNAMED,"Couldn't find workspace");if(null==s.manifest.name)return void e.reportError(a.MessageName.UNNAMED,`Package at ${s.relativeCwd} doesn't have a name`);const c=n.ppath.join(r.cwd,"dist");await n.xfs.mkdirPromise(c,{recursive:!0}),await r.restoreInstallState();const d=n.ppath.join(c,a.structUtils.slugifyIdent(s.manifest.name)+".tgz"),p=n.ppath.resolve(s.cwd,n.npath.toPortablePath(this.directory));if(!await n.xfs.existsPromise(p))return void e.reportError(a.MessageName.UNNAMED,`Build package ${a.structUtils.prettyIdent(t,s.manifest.name)} first`);const u=await n.xfs.readJsonPromise(n.ppath.join(p,n.Filename.manifest)),l=a.structUtils.parseIdent(u.name);if(l.identHash!==s.anchoredDescriptor.identHash)return void e.reportError(a.MessageName.UNNAMED,`Invalid distribution folder: found package ${a.structUtils.prettyIdent(t,l)} but expected ${a.structUtils.prettyIdent(t,s.anchoredDescriptor)}`);const m=o(s,p,u),f=await i.packUtils.genPackStream(m,await i.packUtils.genPackList(m));await n.xfs.writeFilePromise(d,await a.miscUtils.bufferStream(f)),e.reportInfo(null,`Packed ${a.structUtils.prettyIdent(t,l)} into ${a.formatUtils.pretty(t,d,a.FormatType.PATH)}`)})).exitCode()}}c.addPath("snuggery-workspace","pack"),c.addOption("json",c.Boolean("--json")),c.addOption("directory",c.String({required:!0}));const d=require("@yarnpkg/plugin-npm");class p extends s.BaseCommand{constructor(){super(...arguments),this.tag="latest",this.json=!1}async execute(){const t=await a.Configuration.find(this.context.cwd,this.context.plugins);return(await a.StreamReport.start({configuration:t,stdout:this.context.stdout,json:this.json,includeInfos:!0},async e=>{const{project:r,workspace:s}=await a.Project.find(t,this.context.cwd);if(!s)return void e.reportError(a.MessageName.UNNAMED,"Couldn't find workspace");if(null===s.manifest.name||null===s.manifest.version)return void e.reportError(a.MessageName.UNNAMED,"Workspaces must have valid names and versions to be published on an external registry");const i=s.manifest.name,c=n.ppath.join(r.cwd,"dist",a.structUtils.slugifyIdent(i)+".tgz");if(!await n.xfs.existsPromise(c))return void e.reportError(a.MessageName.UNNAMED,`Pack package ${a.structUtils.prettyIdent(t,i)} first`);const p=await n.xfs.readFilePromise(c),u=await(l=p,n.xfs.mktempPromise(async t=>{const e=new n.CwdFS(t);return await a.tgzUtils.extractArchiveTo(l,e,{stripComponents:1}),a.Manifest.fromText(await e.readFilePromise(a.Manifest.fileName,"utf8"))}));var l;if(null==u.name||u.name.identHash!==i.identHash)return void e.reportError(a.MessageName.UNNAMED,`Tarball for package ${u.name&&a.structUtils.prettyIdent(t,u.name)} cannot be published in workspace for ${a.structUtils.prettyIdent(t,i)}`);const m=d.npmConfigUtils.getPublishRegistry(u,{configuration:t}),f=await d.npmPublishUtils.makePublishBody(o(s,s.cwd,u.raw),p,{access:void 0,tag:this.tag,registry:m});try{await d.npmHttpUtils.put(d.npmHttpUtils.getIdentUrl(i),f,{configuration:t,registry:m,ident:i,jsonResponse:!0})}catch(t){if("HTTPError"!==t.name)throw t;{const r=t.response.body&&t.response.body.error?t.response.body.error:`The remote server answered with HTTP ${t.response.statusCode} ${t.response.statusMessage}`;e.reportError(a.MessageName.NETWORK_ERROR,r)}}e.hasErrors()||e.reportInfo(a.MessageName.UNNAMED,"Published "+a.formatUtils.pretty(t,a.structUtils.makeDescriptor(i,u.version),a.FormatType.DESCRIPTOR))})).exitCode()}}p.addPath("snuggery-workspace","publish"),p.addOption("tag",p.String("--tag")),p.addOption("json",p.Boolean("--json"));const u={commands:"1"===process.env.SNUGGERY_YARN?[c,p]:[]}}},e={};function r(s){if(e[s])return e[s].exports;var a=e[s]={exports:{}};return t[s](a,a.exports,r),a.exports}return r.d=(t,e)=>{for(var s in e)r.o(e,s)&&!r.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:e[s]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r(910)})();
return plugin;
}
};